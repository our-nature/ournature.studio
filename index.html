<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
        />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="theme-color" content="#0a0908" />
        <meta
            name="description"
            content="A meditation on nature, technology, and the spaces between. An interactive generative art experience featuring procedural fern fractals and ambient soundscapes."
        />
        <link rel="canonical" href="https://ournature.studio/" />

        <!-- Open Graph -->
        <meta property="og:type" content="website" />
        <meta property="og:url" content="https://ournature.studio/" />
        <meta property="og:title" content="our nature" />
        <meta
            property="og:description"
            content="A meditation on nature, technology, and the spaces between. An interactive generative art experience."
        />
        <meta property="og:image" content="https://ournature.studio/preview.png" />

        <!-- Twitter Card -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="our nature" />
        <meta
            name="twitter:description"
            content="A meditation on nature, technology, and the spaces between. An interactive generative art experience."
        />
        <meta name="twitter:image" content="https://ournature.studio/preview.png" />

        <title>our nature</title>
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ±</text></svg>"
        />
        <style>
            :root {
                --safe-bottom: env(safe-area-inset-bottom, 0px);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            html,
            body {
                width: 100%;
                height: 100%;
                overflow: hidden;
                background: #0a0908;
                font-family:
                    'Helvetica Neue',
                    -apple-system,
                    BlinkMacSystemFont,
                    sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            canvas {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
            }

            #title {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: clamp(20px, 4.5vw, 38px);
                font-weight: 200;
                letter-spacing: 0.35em;
                text-indent: 0.35em;
                text-transform: lowercase;
                color: rgba(255, 250, 245, 0.8);
                z-index: 100;
                pointer-events: none;
                white-space: nowrap;
            }

            #title span {
                opacity: 0;
                transition: opacity 1.2s ease;
            }

            #title.visible span {
                opacity: 1;
            }

            #title.dim span {
                opacity: 0.35;
            }

            #indicators {
                position: fixed;
                bottom: calc(32px + var(--safe-bottom));
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 48px;
                opacity: 0;
                transition: opacity 1s ease;
                pointer-events: none;
            }
            body:hover #indicators,
            body.touch #indicators {
                opacity: 1;
            }

            .indicator {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            .indicator-label {
                font-size: 8px;
                font-weight: 400;
                letter-spacing: 2.5px;
                text-transform: lowercase;
                color: rgba(255, 250, 245, 0.3);
            }

            .indicator-track {
                width: 80px;
                height: 1px;
                background: rgba(255, 250, 245, 0.08);
                position: relative;
                border-radius: 1px;
            }

            .indicator-fill {
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                background: rgba(255, 250, 245, 0.25);
                border-radius: 1px;
                transition: width 0.15s ease-out;
            }

            #sound-toggle {
                position: fixed;
                bottom: calc(32px + var(--safe-bottom));
                right: 32px;
                font-size: 11px;
                font-weight: 400;
                letter-spacing: 2px;
                text-transform: lowercase;
                color: rgba(255, 250, 245, 0.25);
                cursor: pointer;
                padding: 14px 18px;
                border: 1px solid rgba(255, 250, 245, 0.08);
                border-radius: 24px;
                background: rgba(10, 9, 8, 0.5);
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
                transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
                z-index: 100;
                opacity: 0;
            }

            body:hover #sound-toggle,
            body.touch #sound-toggle {
                opacity: 1;
            }

            #sound-toggle:hover {
                color: rgba(255, 250, 245, 0.5);
                border-color: rgba(255, 250, 245, 0.15);
                background: rgba(10, 9, 8, 0.7);
            }

            #sound-toggle.active {
                color: rgba(255, 250, 245, 0.4);
                border-color: rgba(255, 250, 245, 0.12);
            }

            #sound-toggle:focus {
                outline: none;
            }

            #about-toggle {
                position: fixed;
                top: 32px;
                right: 32px;
                font-size: 11px;
                font-weight: 400;
                letter-spacing: 2px;
                text-transform: lowercase;
                color: rgba(255, 250, 245, 0.25);
                cursor: pointer;
                padding: 14px 18px;
                border: none;
                border-radius: 24px;
                background: rgba(10, 9, 8, 0.5);
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
                transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
                z-index: 200;
                opacity: 0;
            }

            body:hover #about-toggle,
            body.touch #about-toggle {
                opacity: 1;
            }

            #about-toggle:hover {
                color: rgba(255, 250, 245, 0.5);
                background: rgba(10, 9, 8, 0.7);
            }

            #about-toggle:focus {
                outline: none;
            }

            #about-overlay {
                position: fixed;
                inset: 0;
                z-index: 150;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(10, 9, 8, 0);
                backdrop-filter: blur(0px);
                -webkit-backdrop-filter: blur(0px);
                opacity: 0;
                pointer-events: none;
                transition:
                    opacity 0.8s ease,
                    background 0.8s ease,
                    backdrop-filter 0.8s ease;
            }

            #about-overlay.visible {
                opacity: 1;
                pointer-events: auto;
                background: rgba(10, 9, 8, 0.4);
                backdrop-filter: blur(1px);
                -webkit-backdrop-filter: blur(1px);
            }

            #about-content {
                max-width: 540px;
                padding: 60px 40px;
                color: rgba(255, 250, 245, 0.65);
                font-size: 13px;
                font-weight: 300;
                line-height: 1.9;
                letter-spacing: 0.01em;
            }

            #about-content section {
                margin-bottom: 48px;
            }

            #about-content section:last-child {
                margin-bottom: 0;
            }

            #about-content p {
                margin: 0;
            }

            #about-content .bio-name {
                font-size: 11px;
                font-weight: 400;
                letter-spacing: 2.5px;
                text-transform: lowercase;
                color: rgba(255, 250, 245, 0.35);
                margin-bottom: 14px;
            }

            #about-content .bio-name a {
                color: inherit;
                text-decoration: none;
                border-bottom: none;
                transition: color 0.3s ease;
            }

            #about-content .bio-name a:hover {
                color: rgba(255, 250, 245, 0.6);
            }

            #about-content a {
                color: rgba(255, 250, 245, 0.5);
                text-decoration: none;
                border-bottom: 1px solid rgba(255, 250, 245, 0.12);
                transition: all 0.3s ease;
            }

            #about-content a:hover {
                color: rgba(255, 250, 245, 0.8);
                border-color: rgba(255, 250, 245, 0.4);
            }

            /* Loading state */
            #loader {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 24px;
                height: 24px;
                border: 1px solid rgba(255, 250, 245, 0.1);
                border-top-color: rgba(255, 250, 245, 0.4);
                border-radius: 50%;
                animation: spin 1s linear infinite;
                z-index: 200;
                transition: opacity 0.5s ease;
            }

            #loader.hidden {
                opacity: 0;
                pointer-events: none;
            }

            @keyframes spin {
                to {
                    transform: translate(-50%, -50%) rotate(360deg);
                }
            }

            @media (max-width: 600px) {
                #indicators {
                    gap: 24px;
                    bottom: calc(24px + var(--safe-bottom));
                }
                .indicator-track {
                    width: 50px;
                }
                #sound-toggle {
                    right: 20px;
                    bottom: calc(24px + var(--safe-bottom));
                    padding: 12px 14px;
                }
                #about-toggle {
                    top: 20px;
                    right: 20px;
                    padding: 12px 14px;
                }
                #about-content {
                    padding: 40px 28px;
                    font-size: 12px;
                }
            }

            @media (max-width: 380px) {
                #indicators {
                    gap: 16px;
                }
                .indicator-track {
                    width: 40px;
                }
                .indicator-label {
                    font-size: 7px;
                    letter-spacing: 2px;
                }
            }
        </style>
        <script type="application/ld+json">
            {
                "@context": "https://schema.org",
                "@type": "WebSite",
                "name": "our nature",
                "url": "https://ournature.studio/",
                "description": "A meditation on nature, technology, and the spaces between. An interactive generative art experience.",
                "creator": [
                    {
                        "@type": "Person",
                        "name": "Lulu Tracy",
                        "url": "https://lulutracy.com"
                    },
                    {
                        "@type": "Person",
                        "name": "Alex Nodeland",
                        "url": "https://alexnodeland.com"
                    }
                ]
            }
        </script>
    </head>
    <body>
        <div id="loader"></div>
        <div id="title">our nature</div>

        <div id="indicators">
            <div class="indicator">
                <div class="indicator-track"><div class="indicator-fill" id="fill-curl"></div></div>
                <div class="indicator-label">curl</div>
            </div>
            <div class="indicator">
                <div class="indicator-track">
                    <div class="indicator-fill" id="fill-spread"></div>
                </div>
                <div class="indicator-label">spread</div>
            </div>
            <div class="indicator">
                <div class="indicator-track">
                    <div class="indicator-fill" id="fill-growth"></div>
                </div>
                <div class="indicator-label">growth</div>
            </div>
        </div>

        <div id="sound-toggle">listen</div>

        <div id="about-toggle">about</div>

        <div id="about-overlay">
            <div id="about-content">
                <section class="philosophy">
                    <p>a meditation on nature, technology, and the spaces between.</p>
                </section>

                <section class="bio">
                    <div class="bio-name">
                        <a href="https://lulutracy.com" target="_blank">lulu tracy</a>
                    </div>
                    <p>
                        visual artist working across painting, design, and digital media. drawn to
                        organic forms and the compositional logic that lets simple marks accumulate
                        into coherent wholes.
                    </p>
                </section>

                <section class="bio">
                    <div class="bio-name">
                        <a href="https://alexnodeland.com" target="_blank">alex nodeland</a>
                    </div>
                    <p>
                        systems engineer and applied mathematician building foundational tools for
                        audio, probability, and autonomous systems. interested in how elegant
                        primitives compose into complex behavior.
                    </p>
                </section>

                <section class="contact">
                    <div class="bio-name">
                        <a href="mailto:contact@ournature.studio">contact</a>
                    </div>
                </section>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
            (function () {
                'use strict';

                // ============================================
                // Detect touch
                // ============================================
                if ('ontouchstart' in window) {
                    document.body.classList.add('touch');
                }

                // ============================================
                // Time-aware palettes with smooth transitions
                // ============================================
                const palettes = {
                    night: {
                        base: { r: 0.06, g: 0.09, b: 0.12 },
                        mid: { r: 0.12, g: 0.2, b: 0.26 },
                        tip: { r: 0.22, g: 0.38, b: 0.45 },
                        soil: { r: 0.04, g: 0.035, b: 0.03 },
                        bg: [0.02, 0.023, 0.03],
                    },
                    dawn: {
                        base: { r: 0.18, g: 0.1, b: 0.08 },
                        mid: { r: 0.4, g: 0.25, b: 0.15 },
                        tip: { r: 0.75, g: 0.5, b: 0.3 },
                        soil: { r: 0.08, g: 0.05, b: 0.03 },
                        bg: [0.045, 0.032, 0.028],
                    },
                    day: {
                        base: { r: 0.08, g: 0.1, b: 0.05 },
                        mid: { r: 0.18, g: 0.28, b: 0.1 },
                        tip: { r: 0.35, g: 0.48, b: 0.18 },
                        soil: { r: 0.06, g: 0.05, b: 0.035 },
                        bg: [0.035, 0.032, 0.025],
                    },
                    dusk: {
                        base: { r: 0.15, g: 0.08, b: 0.08 },
                        mid: { r: 0.32, g: 0.18, b: 0.14 },
                        tip: { r: 0.6, g: 0.35, b: 0.22 },
                        soil: { r: 0.07, g: 0.04, b: 0.035 },
                        bg: [0.04, 0.028, 0.025],
                    },
                };

                function getTimeOfDay() {
                    const hour = new Date().getHours();
                    if (hour >= 22 || hour < 5) return 'night';
                    if (hour >= 5 && hour < 8) return 'dawn';
                    if (hour >= 8 && hour < 17) return 'day';
                    return 'dusk';
                }

                let currentPalette = palettes[getTimeOfDay()];
                let targetPalette = currentPalette;

                function lerpColor(a, b, t) {
                    return {
                        r: a.r + (b.r - a.r) * t,
                        g: a.g + (b.g - a.g) * t,
                        b: a.b + (b.b - a.b) * t,
                    };
                }

                function lerpPalette(a, b, t) {
                    return {
                        base: lerpColor(a.base, b.base, t),
                        mid: lerpColor(a.mid, b.mid, t),
                        tip: lerpColor(a.tip, b.tip, t),
                        soil: lerpColor(a.soil, b.soil, t),
                        bg: [
                            a.bg[0] + (b.bg[0] - a.bg[0]) * t,
                            a.bg[1] + (b.bg[1] - a.bg[1]) * t,
                            a.bg[2] + (b.bg[2] - a.bg[2]) * t,
                        ],
                    };
                }

                let paletteTransition = 0;
                let lastTimeOfDay = getTimeOfDay();

                setInterval(() => {
                    const tod = getTimeOfDay();
                    if (tod !== lastTimeOfDay) {
                        targetPalette = palettes[tod];
                        paletteTransition = 0;
                        lastTimeOfDay = tod;
                    }
                }, 30000);

                // ============================================
                // Presets & Timing
                // ============================================
                const presets = [
                    { curl: 0.04, spread: 0.3, height: 1.6 },
                    { curl: -0.025, spread: 0.4, height: 1.25 },
                    { curl: 0.1, spread: 0.2, height: 2.1 },
                    { curl: -0.06, spread: 0.34, height: 1.85 },
                ];

                const ranges = {
                    curl: { min: -0.15, max: 0.15 },
                    spread: { min: 0.15, max: 0.45 },
                };

                let ifs = { ...presets[0] };

                // ============================================
                // Poisson Disk Sampling for natural distribution
                // ============================================
                function poissonDiskSample(width, height, minDistance, maxAttempts = 30) {
                    const cellSize = minDistance / Math.sqrt(2);
                    const gridWidth = Math.ceil(width / cellSize);
                    const gridHeight = Math.ceil(height / cellSize);
                    const grid = new Array(gridWidth * gridHeight).fill(null);
                    const points = [];
                    const active = [];

                    // Start with center-ish point
                    const firstPoint = { x: width * 0.5, y: height * 0.5 };
                    points.push(firstPoint);
                    active.push(firstPoint);
                    grid[
                        Math.floor(firstPoint.x / cellSize) +
                            Math.floor(firstPoint.y / cellSize) * gridWidth
                    ] = firstPoint;

                    while (active.length > 0) {
                        const idx = Math.floor(Math.random() * active.length);
                        const point = active[idx];
                        let found = false;

                        for (let i = 0; i < maxAttempts; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = minDistance + Math.random() * minDistance;
                            const newX = point.x + Math.cos(angle) * radius;
                            const newY = point.y + Math.sin(angle) * radius;

                            if (newX < 0 || newX >= width || newY < 0 || newY >= height) continue;

                            const gridX = Math.floor(newX / cellSize);
                            const gridY = Math.floor(newY / cellSize);
                            let valid = true;

                            for (let dy = -2; dy <= 2 && valid; dy++) {
                                for (let dx = -2; dx <= 2 && valid; dx++) {
                                    const nx = gridX + dx,
                                        ny = gridY + dy;
                                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                                        const neighbor = grid[nx + ny * gridWidth];
                                        if (neighbor) {
                                            const dist = Math.hypot(
                                                newX - neighbor.x,
                                                newY - neighbor.y,
                                            );
                                            if (dist < minDistance) valid = false;
                                        }
                                    }
                                }
                            }

                            if (valid) {
                                const newPoint = { x: newX, y: newY };
                                points.push(newPoint);
                                active.push(newPoint);
                                grid[gridX + gridY * gridWidth] = newPoint;
                                found = true;
                                break;
                            }
                        }

                        if (!found) active.splice(idx, 1);
                    }
                    return points;
                }

                // ============================================
                // Natural Fern Configuration Generator
                // ============================================
                function generateNaturalFernConfigs() {
                    // Sample in a wide horizontal strip spanning full viewport
                    const sampleWidth = 36; // -18 to +18 in world X
                    const sampleDepth = 10; // Larger depth range for sampling
                    const minSpacing = 2.8; // Sparser spacing for less density

                    const samples = poissonDiskSample(sampleWidth, sampleDepth, minSpacing);

                    return samples
                        .map((sample) => {
                            const worldX = sample.x - sampleWidth / 2; // Center around 0
                            // Map to range from +3 (foreground) to -9 (background)
                            const worldZ = 3 - sample.y * 1.2;

                            // Normalize depth: 0 = foreground (+3), 1 = far background (-9)
                            const normalizedDepth = Math.max(0, Math.min(1, (3 - worldZ) / 12));
                            const depthFactor = 1 - normalizedDepth * 0.65;
                            const baseScale = 0.4 + Math.random() * 0.5;
                            const scale = baseScale * depthFactor;

                            // Per-fern IFS parameter offsets for natural variation
                            const curlOffset = (Math.random() - 0.5) * 0.04;
                            const spreadOffset = (Math.random() - 0.5) * 0.08;
                            const heightOffset = (Math.random() - 0.5) * 0.3;

                            // Subtle rotation/tilt
                            const rotationY = (Math.random() - 0.5) * Math.PI * 0.4;
                            const tilt = (Math.random() - 0.5) * 0.15;

                            // Particle count proportional to scale squared
                            const baseParticles = 70000;
                            const particles = Math.floor(baseParticles * scale * scale);

                            return {
                                x: worldX,
                                y: -0.3 - Math.random() * 0.4, // Ground level variation
                                z: worldZ,
                                scale: Math.max(0.25, scale),
                                depthLayer: normalizedDepth, // 0 = near, 1 = far
                                rotationY,
                                tilt,
                                curlOffset,
                                spreadOffset,
                                heightOffset,
                                particles: Math.max(12000, Math.min(80000, particles)),
                                phaseOffset: Math.random() * Math.PI * 2,
                            };
                        })
                        .sort((a, b) => a.z - b.z); // Back to front for rendering
                }

                // 4:3 polyrhythm (faster animation)
                const GROWTH_PERIOD = 6500;
                const MORPH_PERIOD = 8666;

                // ============================================
                // Three.js Setup
                // ============================================
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 1000);
                camera.position.set(0, 4, 26);
                camera.lookAt(0, 3.5, 0);

                const renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: false,
                    powerPreference: 'high-performance',
                });
                renderer.setSize(innerWidth, innerHeight);
                renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
                document.body.appendChild(renderer.domElement);

                // Render targets
                const rtParams = {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                };
                const rt = new THREE.WebGLRenderTarget(innerWidth, innerHeight, rtParams);
                const rtBloom1 = new THREE.WebGLRenderTarget(
                    innerWidth / 2,
                    innerHeight / 2,
                    rtParams,
                );
                const rtBloom2 = new THREE.WebGLRenderTarget(
                    innerWidth / 2,
                    innerHeight / 2,
                    rtParams,
                );
                let ghostA = new THREE.WebGLRenderTarget(innerWidth, innerHeight, rtParams);
                let ghostB = new THREE.WebGLRenderTarget(innerWidth, innerHeight, rtParams);

                const postScene = new THREE.Scene();
                const postCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                const postGeo = new THREE.PlaneGeometry(2, 2);

                // Shaders
                const blurMat = new THREE.ShaderMaterial({
                    uniforms: {
                        tDiffuse: { value: null },
                        direction: { value: new THREE.Vector2() },
                        resolution: { value: new THREE.Vector2() },
                    },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
                    fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 direction;
                uniform vec2 resolution;
                varying vec2 vUv;
                void main() {
                    vec2 texel = 1.0 / resolution;
                    vec4 c = vec4(0.0);
                    float weights[5]; 
                    weights[0] = 0.227027; weights[1] = 0.1945946; weights[2] = 0.1216216; 
                    weights[3] = 0.054054; weights[4] = 0.016216;
                    c += texture2D(tDiffuse, vUv) * weights[0];
                    for(int i = 1; i < 5; i++) {
                        vec2 offset = direction * texel * float(i) * 2.0;
                        c += texture2D(tDiffuse, vUv + offset) * weights[i];
                        c += texture2D(tDiffuse, vUv - offset) * weights[i];
                    }
                    gl_FragColor = c;
                }
            `,
                });

                const ghostMat = new THREE.ShaderMaterial({
                    uniforms: {
                        tPrev: { value: null },
                        tCurr: { value: null },
                    },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
                    fragmentShader: `
                uniform sampler2D tPrev;
                uniform sampler2D tCurr;
                varying vec2 vUv;
                void main() {
                    vec4 prev = texture2D(tPrev, vUv) * 0.975;
                    vec4 curr = texture2D(tCurr, vUv);
                    gl_FragColor = max(prev, curr * 0.5);
                }
            `,
                });

                const compositeMat = new THREE.ShaderMaterial({
                    uniforms: {
                        tDiffuse: { value: null },
                        tBloom: { value: null },
                        tGhost: { value: null },
                        time: { value: 0 },
                        bgColor: { value: new THREE.Vector3(0.035, 0.032, 0.025) },
                        resolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
                    },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
                    fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tBloom;
                uniform sampler2D tGhost;
                uniform float time;
                uniform vec3 bgColor;
                uniform vec2 resolution;
                varying vec2 vUv;
                
                float hash(vec2 p) {
                    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
                    p3 += dot(p3, p3.yzx + 33.33);
                    return fract((p3.x + p3.y) * p3.z);
                }
                
                float noise(vec2 uv, float scale) {
                    vec2 i = floor(uv * scale);
                    vec2 f = fract(uv * scale);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }
                
                void main() {
                    vec4 scene = texture2D(tDiffuse, vUv);
                    vec4 bloom = texture2D(tBloom, vUv);
                    vec4 ghost = texture2D(tGhost, vUv);

                    // Reflection: mirror from top portion into bottom
                    float reflectLine = 0.35;  // Where reflection starts
                    vec4 reflection = vec4(0.0);
                    if (vUv.y < reflectLine) {
                        vec2 reflectUV = vec2(vUv.x, reflectLine + (reflectLine - vUv.y));
                        vec4 reflectScene = texture2D(tDiffuse, reflectUV);
                        vec4 reflectGhost = texture2D(tGhost, reflectUV);
                        float reflectFade = smoothstep(0.0, reflectLine, vUv.y);
                        reflection = mix(reflectScene, reflectGhost * 0.5, 0.3) * (1.0 - reflectFade) * 0.25;
                    }

                    // Background
                    vec3 color = bgColor;

                    // Reflection layer (underneath everything)
                    color = mix(color, reflection.rgb, reflection.a * 0.6);

                    // Ghost layer (memories)
                    color = mix(color, ghost.rgb * 0.6, ghost.a * 0.4);

                    // Main scene with subtle DOF (distant ferns slightly blurred)
                    vec3 sharpScene = scene.rgb;
                    vec3 blurredScene = bloom.rgb * 1.8;  // Bloom serves as blur proxy
                    float dofAmount = smoothstep(0.3, 0.5, vUv.y) * 0.2;  // More blur at top (distant)
                    vec3 dofScene = mix(sharpScene, blurredScene, dofAmount);
                    color = mix(color, dofScene, scene.a);

                    // Bloom
                    color += bloom.rgb * 0.5;
                    
                    // Paper texture (subtle)
                    float grain = noise(vUv + time * 0.005, 350.0);
                    float fiber = noise(vUv * vec2(1.0, 2.5) + time * 0.002, 180.0);
                    color += (grain - 0.5) * 0.002;
                    color += (fiber - 0.5) * 0.006;
                    
                    // Vignette
                    vec2 center = vUv - 0.5;
                    color *= 1.0 - dot(center, center) * 0.5;
                    
                    // Tone mapping
                    color = color / (color + 0.65);
                    color = pow(color, vec3(0.94, 0.96, 1.0));
                    
                    // Subtle color grading
                    color = mix(color, color * vec3(1.02, 1.0, 0.97), 0.3);
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
                });

                const postQuad = new THREE.Mesh(postGeo, compositeMat);
                postScene.add(postQuad);

                // ============================================
                // Particle material
                // ============================================
                function createParticleMaterial() {
                    return new THREE.ShaderMaterial({
                        uniforms: {
                            pr: { value: renderer.getPixelRatio() },
                            depthFade: { value: 1.0 },
                        },
                        vertexShader: `
                    attribute float size;
                    attribute float depth;
                    varying vec3 vColor;
                    varying float vAlpha;
                    uniform float pr;
                    uniform float depthFade;
                    void main() {
                        vColor = color;
                        vAlpha = 1.0 - depth * depthFade * 0.3;
                        vec4 mv = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * pr * (160.0 / -mv.z);
                        gl_Position = projectionMatrix * mv;
                    }
                `,
                        fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    void main() {
                        float d = length(gl_PointCoord - 0.5);
                        float n = fract(sin(dot(gl_PointCoord, vec2(12.9898, 78.233))) * 43758.5453);
                        float edge = 0.32 + n * 0.08;
                        float a = 1.0 - smoothstep(edge, 0.5, d);
                        float glow = exp(-d * 2.2) * 0.25;
                        gl_FragColor = vec4(vColor * (1.0 + glow), a * vAlpha * 0.85);
                    }
                `,
                        transparent: true,
                        vertexColors: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                    });
                }

                // ============================================
                // IFS Transform
                // ============================================
                function transform(x, y, p) {
                    const r = Math.random();
                    if (r < 0.01) {
                        return { x: 0, y: 0.16 * y };
                    } else if (r < 0.86) {
                        return {
                            x: 0.85 * x + p.curl * y,
                            y: -p.curl * x + 0.85 * y + p.height,
                        };
                    } else if (r < 0.93) {
                        return {
                            x: p.spread * x - p.spread * 0.85 * y,
                            y: p.spread * 0.85 * x + p.spread * y + p.height,
                        };
                    } else {
                        return {
                            x: -p.spread * x + p.spread * 0.85 * y,
                            y: p.spread * 0.85 * x + p.spread * y + 0.44,
                        };
                    }
                }

                // ============================================
                // Fern creation
                // ============================================
                const ferns = [];

                function createFern(config) {
                    // Destructure config with defaults
                    const {
                        x = 0,
                        y = 0,
                        z = 0,
                        scale = 1,
                        depthLayer = 0,
                        rotationY = 0,
                        tilt = 0,
                        curlOffset = 0,
                        spreadOffset = 0,
                        heightOffset = 0,
                        particles = 50000,
                        phaseOffset = 0,
                    } = config;

                    const count = particles;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(count * 3);
                    const colors = new Float32Array(count * 3);
                    const sizes = new Float32Array(count);
                    const depths = new Float32Array(count);
                    const baseSizes = new Float32Array(count);

                    for (let i = 0; i < count; i++) {
                        baseSizes[i] = (0.012 + Math.random() * 0.01) * scale;
                        depths[i] = depthLayer;
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                    geometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));

                    const material = createParticleMaterial();
                    const pointsObj = new THREE.Points(geometry, material);
                    scene.add(pointsObj);

                    return {
                        geometry,
                        material,
                        particles: pointsObj,
                        positions,
                        colors,
                        sizes,
                        baseSizes,
                        depths,
                        count,
                        scale,
                        offsetX: x,
                        offsetY: y,
                        offsetZ: z,
                        depthLayer,
                        visible: 0,
                        phase: phaseOffset,
                        rotationY,
                        tilt,
                        curlOffset,
                        spreadOffset,
                        heightOffset,
                    };
                }

                function updateFern(fern, params, palette, visibleRatio) {
                    // Apply per-fern parameter offsets
                    const localParams = {
                        curl: params.curl + (fern.curlOffset || 0),
                        spread: params.spread + (fern.spreadOffset || 0),
                        height: params.height + (fern.heightOffset || 0),
                    };

                    // Precompute rotation matrices
                    const cosR = Math.cos(fern.rotationY || 0);
                    const sinR = Math.sin(fern.rotationY || 0);
                    const cosT = Math.cos(fern.tilt || 0);
                    const sinT = Math.sin(fern.tilt || 0);

                    let x = 0,
                        y = 0;
                    const {
                        positions,
                        colors,
                        sizes,
                        baseSizes,
                        count,
                        scale,
                        offsetX,
                        offsetY,
                        offsetZ,
                    } = fern;
                    const targetVisible = Math.floor(count * visibleRatio);

                    // Depth-based color attenuation for atmospheric perspective
                    const depthFade = 1 - (fern.depthLayer || 0) * 0.5;

                    for (let i = 0; i < count; i++) {
                        const p = transform(x, y, localParams);
                        x = Math.max(-15, Math.min(15, p.x));
                        y = Math.max(-15, Math.min(15, p.y));

                        // Scale the IFS output
                        let px = p.x * scale;
                        let py = p.y * scale;
                        let pz = (Math.random() - 0.5) * 0.05 * scale;

                        // Apply tilt (rotation around X axis)
                        const tiltedY = py * cosT - pz * sinT;
                        const tiltedZ = py * sinT + pz * cosT;
                        py = tiltedY;
                        pz = tiltedZ;

                        // Apply rotation around Y axis
                        const rotatedX = px * cosR + pz * sinR;
                        const rotatedZ = -px * sinR + pz * cosR;

                        positions[i * 3] = rotatedX + offsetX;
                        positions[i * 3 + 1] = py + offsetY;
                        positions[i * 3 + 2] = rotatedZ + offsetZ;

                        const t = Math.min(1, Math.max(0, p.y / 11));
                        const col = lerpColor(palette.base, palette.tip, t);
                        colors[i * 3] = col.r * depthFade;
                        colors[i * 3 + 1] = col.g * depthFade;
                        colors[i * 3 + 2] = col.b * depthFade;

                        sizes[i] = i < targetVisible ? baseSizes[i] : 0;
                    }

                    fern.visible = targetVisible;
                    fern.geometry.attributes.position.needsUpdate = true;
                    fern.geometry.attributes.color.needsUpdate = true;
                    fern.geometry.attributes.size.needsUpdate = true;
                }

                // ============================================
                // Soil
                // ============================================
                let soil;

                function createSoil() {
                    const count = 5000;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(count * 3);
                    const colors = new Float32Array(count * 3);
                    const sizes = new Float32Array(count);
                    const depths = new Float32Array(count);

                    for (let i = 0; i < count; i++) {
                        positions[i * 3] = (Math.random() - 0.5) * 10;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 0.6 - 0.6;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 4;
                        sizes[i] = 0.005 + Math.random() * 0.012;
                        depths[i] = Math.random();
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                    geometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));

                    const material = createParticleMaterial();
                    const particles = new THREE.Points(geometry, material);
                    scene.add(particles);

                    soil = { geometry, particles, colors, count };
                }

                function updateSoilColors(palette) {
                    const { colors, count } = soil;
                    for (let i = 0; i < count; i++) {
                        const fade = 0.25 + Math.random() * 0.35;
                        colors[i * 3] = palette.soil.r * fade;
                        colors[i * 3 + 1] = palette.soil.g * fade;
                        colors[i * 3 + 2] = palette.soil.b * fade;
                    }
                    soil.geometry.attributes.color.needsUpdate = true;
                }

                // ============================================
                // Audio
                // ============================================
                let audioCtx,
                    masterGain,
                    breathGain,
                    audioStarted = false;

                function initAudio() {
                    if (audioStarted) return;
                    audioStarted = true;

                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                    // Master chain
                    masterGain = audioCtx.createGain();
                    masterGain.gain.value = 0;

                    const compressor = audioCtx.createDynamicsCompressor();
                    compressor.threshold.value = -24;
                    compressor.ratio.value = 4;

                    masterGain.connect(compressor);
                    compressor.connect(audioCtx.destination);

                    // Breath-controlled gain
                    breathGain = audioCtx.createGain();
                    breathGain.gain.value = 0.5;
                    breathGain.connect(masterGain);

                    // Reverb (simple convolution approximation via delays)
                    const reverbGain = audioCtx.createGain();
                    reverbGain.gain.value = 0.3;
                    reverbGain.connect(masterGain);

                    // Drone oscillators (rich harmonic series)
                    const fundamentals = [55, 110];
                    const harmonics = [1, 2, 3, 4, 5, 6, 8];

                    fundamentals.forEach((fund) => {
                        harmonics.forEach((h, i) => {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            const pan = audioCtx.createStereoPanner();

                            osc.type = i < 3 ? 'sine' : 'triangle';
                            osc.frequency.value = fund * h;
                            osc.detune.value = (Math.random() - 0.5) * 8;

                            const vol = 0.15 / Math.pow(h, 1.2);
                            gain.gain.value = vol;
                            pan.pan.value = (Math.random() - 0.5) * 0.6;

                            osc.connect(gain);
                            gain.connect(pan);
                            pan.connect(breathGain);
                            pan.connect(reverbGain);
                            osc.start();
                        });
                    });

                    // High shimmer
                    for (let i = 0; i < 3; i++) {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        const lfo = audioCtx.createOscillator();
                        const lfoGain = audioCtx.createGain();

                        osc.type = 'sine';
                        osc.frequency.value = 880 * (i + 1) + Math.random() * 20;

                        lfo.frequency.value = 0.1 + Math.random() * 0.2;
                        lfoGain.gain.value = 0.01;

                        lfo.connect(lfoGain);
                        lfoGain.connect(gain.gain);

                        gain.gain.value = 0.008;
                        osc.connect(gain);
                        gain.connect(breathGain);

                        osc.start();
                        lfo.start();
                    }

                    // Filtered noise (wind)
                    const bufferSize = audioCtx.sampleRate * 3;
                    const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        noiseData[i] = (Math.random() - 0.5) * 0.5;
                    }

                    const noise = audioCtx.createBufferSource();
                    noise.buffer = noiseBuffer;
                    noise.loop = true;

                    const noiseFilter = audioCtx.createBiquadFilter();
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.value = 300;
                    noiseFilter.Q.value = 0.8;

                    const noiseGain = audioCtx.createGain();
                    noiseGain.gain.value = 0.015;

                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(breathGain);
                    noise.start();

                    // Fade in
                    masterGain.gain.linearRampToValueAtTime(0.18, audioCtx.currentTime + 4);

                    document.getElementById('sound-toggle').textContent = 'listening';
                    document.getElementById('sound-toggle').classList.add('active');
                }

                function stopAudio() {
                    if (!audioStarted) return;
                    masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.5);
                    setTimeout(() => {
                        audioCtx.close();
                        audioStarted = false;
                    }, 1600);
                    document.getElementById('sound-toggle').textContent = 'listen';
                    document.getElementById('sound-toggle').classList.remove('active');
                }

                function updateAudio(breath) {
                    if (!audioStarted || !breathGain) return;
                    breathGain.gain.linearRampToValueAtTime(
                        0.25 + breath * 0.75,
                        audioCtx.currentTime + 0.1,
                    );
                }

                document.getElementById('sound-toggle').addEventListener('click', () => {
                    audioStarted ? stopAudio() : initAudio();
                });

                // Keyboard shortcut: 'l' to toggle sound
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'l' || e.key === 'L') {
                        audioStarted ? stopAudio() : initAudio();
                    }
                });

                // ============================================
                // About Overlay
                // ============================================
                const aboutToggle = document.getElementById('about-toggle');
                const aboutOverlay = document.getElementById('about-overlay');
                const titleEl = document.getElementById('title');
                let titleCycleTimer = null;

                function startTitleCycle() {
                    // Initial dim after 6 seconds
                    titleCycleTimer = setTimeout(() => {
                        titleEl.classList.add('dim');
                        // Then cycle every 12 seconds
                        titleCycleTimer = setInterval(() => {
                            if (!aboutOverlay.classList.contains('visible')) {
                                titleEl.classList.toggle('dim');
                            }
                        }, 12000);
                    }, 6000);
                }

                function restartTitleAnimation() {
                    // Clear any existing cycle
                    clearTimeout(titleCycleTimer);
                    clearInterval(titleCycleTimer);

                    // Reset title state
                    titleEl.style.opacity = '';
                    titleEl.classList.remove('visible', 'dim');

                    // Temporarily disable transitions to reset spans to opacity 0
                    const spans = titleEl.querySelectorAll('span');
                    // Save transitionDelay before disabling (shorthand resets it)
                    const delays = Array.from(spans).map((span) => span.style.transitionDelay);
                    spans.forEach((span) => (span.style.transition = 'none'));
                    void titleEl.offsetHeight; // Force reflow

                    // Re-enable transitions and restore delays
                    spans.forEach((span, i) => {
                        span.style.transition = '';
                        span.style.transitionDelay = delays[i];
                    });
                    titleEl.classList.add('visible');

                    // Restart the cycle
                    startTitleCycle();
                }

                function openAbout() {
                    aboutOverlay.classList.add('visible');
                    aboutToggle.textContent = 'close';
                    titleEl.style.opacity = '0';
                }

                function closeAbout() {
                    aboutOverlay.classList.remove('visible');
                    aboutToggle.textContent = 'about';
                    restartTitleAnimation();
                }

                aboutToggle.addEventListener('click', () => {
                    aboutOverlay.classList.contains('visible') ? closeAbout() : openAbout();
                });

                // Keyboard shortcuts for about overlay
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'a' || e.key === 'A') {
                        aboutOverlay.classList.contains('visible') ? closeAbout() : openAbout();
                    } else if (e.key === 'Escape' && aboutOverlay.classList.contains('visible')) {
                        closeAbout();
                    }
                });

                // ============================================
                // UI Updates
                // ============================================
                const fills = {
                    curl: document.getElementById('fill-curl'),
                    spread: document.getElementById('fill-spread'),
                    growth: document.getElementById('fill-growth'),
                };

                function updateIndicators(breath) {
                    const curlPct =
                        ((ifs.curl - ranges.curl.min) / (ranges.curl.max - ranges.curl.min)) * 100;
                    const spreadPct =
                        ((ifs.spread - ranges.spread.min) /
                            (ranges.spread.max - ranges.spread.min)) *
                        100;

                    fills.curl.style.width = curlPct + '%';
                    fills.spread.style.width = spreadPct + '%';
                    fills.growth.style.width = breath * 100 + '%';
                }

                // ============================================
                // Camera with parallax
                // ============================================
                let mouseX = 0,
                    mouseY = 0;
                let cameraAngle = 0;

                document.addEventListener('mousemove', (e) => {
                    mouseX = (e.clientX / innerWidth - 0.5) * 2;
                    mouseY = (e.clientY / innerHeight - 0.5) * 2;
                });

                function updateCamera() {
                    cameraAngle += 0.00012;

                    const baseX = Math.sin(cameraAngle) * 1.0;
                    const baseY = 4 + Math.sin(cameraAngle * 0.6) * 0.3;
                    const baseZ = 26 + Math.cos(cameraAngle * 0.8) * 0.6;

                    // Subtle parallax from mouse
                    const parallaxX = mouseX * 0.5;
                    const parallaxY = mouseY * 0.25;

                    camera.position.x += (baseX + parallaxX - camera.position.x) * 0.02;
                    camera.position.y += (baseY - parallaxY - camera.position.y) * 0.02;
                    camera.position.z += (baseZ - camera.position.z) * 0.02;

                    camera.lookAt(0, 3.5, 0);
                }

                // ============================================
                // Easing
                // ============================================
                function easeInOutSine(t) {
                    return -(Math.cos(Math.PI * t) - 1) / 2;
                }

                // ============================================
                // Init
                // ============================================
                function init() {
                    // Generate natural fern layout using Poisson disk sampling
                    const fernConfigs = generateNaturalFernConfigs();

                    fernConfigs.forEach((config) => {
                        ferns.push(createFern(config));
                    });

                    createSoil();
                    updateSoilColors(currentPalette);

                    // Create letter-by-letter spans for title animation
                    const titleEl = document.getElementById('title');
                    const titleText = titleEl.textContent;
                    titleEl.textContent = '';
                    titleText.split('').forEach((char, i) => {
                        const span = document.createElement('span');
                        span.textContent = char === ' ' ? '\u00A0' : char;
                        span.style.transitionDelay = i * 120 + 'ms';
                        titleEl.appendChild(span);
                    });

                    // Hide loader, show title
                    setTimeout(() => {
                        document.getElementById('loader').classList.add('hidden');
                        titleEl.classList.add('visible');
                        startTitleCycle();
                    }, 800);
                }

                // ============================================
                // Resize
                // ============================================
                function handleResize() {
                    const w = innerWidth,
                        h = innerHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);

                    [rt, ghostA, ghostB].forEach((t) => t.setSize(w, h));
                    [rtBloom1, rtBloom2].forEach((t) => t.setSize(w / 2, h / 2));
                    compositeMat.uniforms.resolution.value.set(w, h);
                }

                window.addEventListener('resize', handleResize);

                // ============================================
                // Animation
                // ============================================
                let time = 0;
                const startTime = performance.now();

                function animate() {
                    requestAnimationFrame(animate);

                    const now = performance.now() - startTime;
                    time += 0.006;

                    // Palette transition
                    if (paletteTransition < 1) {
                        paletteTransition += 0.002;
                        currentPalette = lerpPalette(currentPalette, targetPalette, 0.01);
                        updateSoilColors(currentPalette);
                    }

                    // Growth LFO (4 cycles)
                    const growthPhase = (now % GROWTH_PERIOD) / GROWTH_PERIOD;
                    const breath = (Math.sin(growthPhase * Math.PI * 2) + 1) / 2;

                    // Param morphing (3 cycles)
                    const morphTime = now % (MORPH_PERIOD * presets.length);
                    const presetIdx = Math.floor(morphTime / MORPH_PERIOD);
                    const morphT = easeInOutSine((morphTime % MORPH_PERIOD) / MORPH_PERIOD);
                    const nextIdx = (presetIdx + 1) % presets.length;

                    ifs.curl =
                        presets[presetIdx].curl +
                        (presets[nextIdx].curl - presets[presetIdx].curl) * morphT;
                    ifs.spread =
                        presets[presetIdx].spread +
                        (presets[nextIdx].spread - presets[presetIdx].spread) * morphT;
                    ifs.height =
                        presets[presetIdx].height +
                        (presets[nextIdx].height - presets[presetIdx].height) * morphT;

                    // Update all ferns with per-fern phase offsets
                    ferns.forEach((fern) => {
                        // Use each fern's unique phase offset for staggered breathing
                        const fernPhase = growthPhase + fern.phase / (Math.PI * 2);
                        const fernBreath = (Math.sin(fernPhase * Math.PI * 2) + 1) / 2;

                        // Larger ferns show more particles at rest, smaller breathe more dramatically
                        const minVisible = 0.25 + fern.scale * 0.1;
                        const visibleRatio = minVisible + (1 - minVisible) * fernBreath;

                        updateFern(fern, ifs, currentPalette, visibleRatio);
                    });

                    updateIndicators(breath);
                    updateAudio(breath);
                    updateCamera();

                    // Update background color
                    compositeMat.uniforms.bgColor.value.set(...currentPalette.bg);

                    // Render
                    renderer.setRenderTarget(rt);
                    renderer.setClearColor(0x000000, 0);
                    renderer.clear();
                    renderer.render(scene, camera);

                    // Ghost accumulation
                    postQuad.material = ghostMat;
                    ghostMat.uniforms.tPrev.value = ghostA.texture;
                    ghostMat.uniforms.tCurr.value = rt.texture;
                    renderer.setRenderTarget(ghostB);
                    renderer.render(postScene, postCam);
                    [ghostA, ghostB] = [ghostB, ghostA];

                    // Bloom
                    postQuad.material = blurMat;
                    blurMat.uniforms.tDiffuse.value = rt.texture;
                    blurMat.uniforms.direction.value.set(1, 0);
                    blurMat.uniforms.resolution.value.set(rtBloom1.width, rtBloom1.height);
                    renderer.setRenderTarget(rtBloom1);
                    renderer.render(postScene, postCam);

                    blurMat.uniforms.tDiffuse.value = rtBloom1.texture;
                    blurMat.uniforms.direction.value.set(0, 1);
                    renderer.setRenderTarget(rtBloom2);
                    renderer.render(postScene, postCam);

                    // Composite
                    postQuad.material = compositeMat;
                    compositeMat.uniforms.tDiffuse.value = rt.texture;
                    compositeMat.uniforms.tBloom.value = rtBloom2.texture;
                    compositeMat.uniforms.tGhost.value = ghostA.texture;
                    compositeMat.uniforms.time.value = time;
                    renderer.setRenderTarget(null);
                    renderer.render(postScene, postCam);
                }

                init();
                animate();
            })();
        </script>
    </body>
</html>
